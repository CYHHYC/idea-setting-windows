<application>
  <component name="AppStorage">
    <histories>
      <item value="check Is Under Approval" />
      <item value="校验是否在审批中" />
      <item value="check Is Aprronvaling" />
      <item value="矩阵经理工号字符串" />
      <item value="总裁审核工号字符串" />
      <item value="总裁决策工号字符串" />
      <item value="开阀批准报告" />
      <item value="获取组织n级部门负责人信息" />
      <item value="select Org Manager Info" />
      <item value="中心部门code" />
      <item value="负责人" />
      <item value="中心负责人" />
      <item value="级别" />
      <item value="等级" />
      <item value="获取中心负责人" />
      <item value="重新签批" />
      <item value="责任人用户名列表" />
      <item value="current user has no permission to this project" />
      <item value="approval User Names" />
      <item value="APPLY" />
      <item value="不适用申请" />
      <item value="签批人" />
      <item value="责任人" />
      <item value="阀门交付物签批" />
      <item value="G 10固定成员" />
      <item value="valve" />
      <item value="Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is {@link java.util.stream.BaseStreamclose() closed} after its contents have been placed into this stream. (If a mapped stream is {@code null} an empty stream is used, instead.) &lt;p&gt;This is an &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;intermediate operation&lt;a&gt;. @apiNote The {@code flatMap()} operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream. &lt;p&gt;&lt;b&gt;Examples.&lt;b&gt; &lt;p&gt;If {@code orders} is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders: &lt;pre&gt;{@code orders.flatMap(order -&gt; order.getLineItems().stream())... }&lt;pre&gt; &lt;p&gt;If {@code path} is the path to a file, then the following produces a stream of the {@code words} contained in that file: &lt;pre&gt;{@code Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8); Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(&quot; +&quot;))); }&lt;pre&gt; The {@code mapper} function passed to {@code flatMap} splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array. @param &lt;R&gt; The element type of the new stream @param mapper a &lt;a href=&quot;package-summary.htmlNonInterference&quot;&gt;non-interfering&lt;a&gt;, &lt;a href=&quot;package-summary.htmlStatelessness&quot;&gt;stateless&lt;a&gt; function to apply to each element which produces a stream of new values @return the new stream" />
      <item value="Returns a {@code Stream} consisting of the elements of this stream, each boxed to an {@code Integer}. &lt;p&gt;This is an &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;intermediate operation&lt;a&gt;. @return a {@code Stream} consistent of the elements of this stream, each boxed to an {@code Integer}" />
      <item value="步骤整合" />
      <item value="不合法" />
      <item value="Approval" />
      <item value="出现业务异常" />
      <item value="Eligible to terminate" />
      <item value="Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination" />
      <item value="Causes this thread to begin execution; the Java Virtual Machine calls the &lt;code&gt;run&lt;code&gt; method of this thread. &lt;p&gt; The result is that two threads are running concurrently: the current thread (which returns from the call to the &lt;code&gt;start&lt;code&gt; method) and the other thread (which executes its &lt;code&gt;run&lt;code&gt; method). &lt;p&gt; It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution. @exception IllegalThreadStateException if the thread was already started. @see run() @see stop()" />
      <item value="校验是否可禁用" />
      <item value="拼接" />
      <item value="get If Present" />
      <item value="biz Unique Key" />
      <item value="length" />
      <item value="Deprecated" />
      <item value="Column" />
      <item value="组件" />
      <item value="Compent Export Config" />
      <item value="导出明细表" />
      <item value="表单明细" />
      <item value="send" />
      <item value="Sent" />
      <item value="荷兰" />
      <item value="biz" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1688459304722" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1705997059059" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="-1109" />
    <option name="newTranslationDialogY" value="445" />
    <histories>
      <item value="Retrieve or build a default executor for this advice instance. An executor returned from here will be cached for further use. &lt;p&gt; The default implementation searches for a unique {@link TaskExecutor} bean in the context, or for an {@link Executor} bean named &quot;taskExecutor&quot; otherwise. If neither of the two is resolvable, this implementation will return {@code null}. @return the default executor, or {@code null} if none available @see AsyncExecutionAspectSupportgetDefaultExecutor(org.springframework.beans.factory.BeanFactory)" />
      <item value="supplier" />
      <item value="Configuration constants for internal sharing across subpackages. @author Juergen Hoeller @since 4.1" />
      <item value="Returns {@link ProxyAsyncConfiguration} or {@code AspectJAsyncConfiguration} for {@code PROXY} and {@code ASPECTJ} values of {@link EnableAsyncmode()}, respectively." />
      <item value="Configure this post-processor with the given executor and exception handler suppliers, applying the corresponding default if a supplier is not resolvable. @since 5.1" />
      <item value="factor" />
      <item value="Causes the current thread to wait until it is awakened, typically by being &lt;em&gt;notified&lt;em&gt; or &lt;em&gt;interrupted&lt;em&gt;. &lt;p&gt; In all respects, this method behaves as if {@code wait(0L, 0)} had been called. See the specification of the {@link wait(long, int)} method for details. @throws IllegalMonitorStateException if the current thread is not the owner of the object's monitor @throws InterruptedException if any thread interrupted the current thread before or while the current thread was waiting. The &lt;em&gt;interrupted status&lt;em&gt; of the current thread is cleared when this exception is thrown. @see notify() @see notifyAll() @see wait(long) @see wait(long, int)" />
      <item value="Equivalent to {@link convert(long, TimeUnit) NANOSECONDS.convert(duration, this)}. @param duration the duration @return the converted duration, or {@code Long.MIN_VALUE} if conversion would negatively overflow, or {@code Long.MAX_VALUE} if it would positively overflow." />
      <item value="suspended Call Back Handle" />
      <item value="Returns a {@code Collector} implementing a cascaded &quot;group by&quot; operation on input elements of type {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream {@code Collector}. &lt;p&gt;The classification function maps elements to some key type {@code K}. The downstream collector operates on elements of type {@code T} and produces a result of type {@code D}. The resulting collector produces a {@code Map&lt;K, D&gt;}. &lt;p&gt;There are no guarantees on the type, mutability, serializability, or thread-safety of the {@code Map} returned. &lt;p&gt;For example, to compute the set of last names of people in each city: &lt;pre&gt;{@code Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); }&lt;pre&gt; @implNote The returned {@code Collector} is not concurrent. For parallel stream pipelines, the {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using {@link groupingByConcurrent(Function, Collector)} may offer better parallel performance. @param &lt;T&gt; the type of the input elements @param &lt;K&gt; the type of the keys @param &lt;A&gt; the intermediate accumulation type of the downstream collector @param &lt;D&gt; the result type of the downstream reduction @param classifier a classifier function mapping input elements to keys @param downstream a {@code Collector} implementing the downstream reduction @return a {@code Collector} implementing the cascaded group-by operation @see groupingBy(Function) @see groupingBy(Function, Supplier, Collector) @see groupingByConcurrent(Function, Collector)" />
      <item value="Flips this buffer. The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded. &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;i&gt; operations, invoke this method to prepare for a sequence of channel-write or relative &lt;i&gt;get&lt;i&gt; operations. For example: &lt;blockquote&gt;&lt;pre&gt; buf.put(magic); Prepend header in.read(buf); Read data into rest of buffer buf.flip(); Flip buffer out.write(buf); Write header + data to channel&lt;pre&gt;&lt;blockquote&gt; &lt;p&gt; This method is often used in conjunction with the {@link java.nio.ByteBuffercompact compact} method when transferring data from one place to another. &lt;p&gt; @return This buffer" />
      <item value="key Allowed" />
      <item value="A {@code Closeable} is a source or destination of data that can be closed. The close method is invoked to release resources that the object is holding (such as open files). @since" />
      <item value="Custom Config" />
      <item value="Costom Config" />
      <item value="自定义" />
      <item value="REVISE" />
      <item value="Publish Application Sor Service" />
      <item value="Permission Application Service" />
      <item value="Company Standard Abolish Service" />
      <item value="通知" />
      <item value="Approver" />
      <item value="analysis Point" />
      <item value="create Model Point" />
      <item value="递归" />
      <item value="算法" />
      <item value="Collapse Builder" />
      <item value="探索者" />
      <item value="explorer" />
      <item value="agenda" />
      <item value="密级" />
      <item value="运维需求" />
      <item value="expect" />
      <item value="except" />
      <item value="标准3 d" />
      <item value="stand 3 d Type" />
      <item value="actual Editable" />
      <item value="Copy the property values of the given source bean into the given target bean. &lt;p&gt;Note: The source and target classes do not have to match or even be derived from each other, as long as the properties match. Any bean properties that the source bean exposes but the target bean does not will silently be ignored. &lt;p&gt;As of Spring Framework 5.3, this method honors generic type information when matching properties in the source and target objects. See the documentation for {@link copyProperties(Object, Object)} for details. @param source the source bean @param target the target bean @param editable the class (or interface) to restrict property setting to @param ignoreProperties array of property names to ignore @throws BeansException if the copying failed @see BeanWrapper" />
      <item value="commit" />
      <item value="distinguish commercial commit" />
      <item value="恶魔" />
      <item value="乏味" />
      <item value="枯燥的" />
      <item value="Check if host matches the registered value. @param registered the registered host. Can be null. @param requested the requested host. Can be null. @return true if they match" />
      <item value="get Scheme" />
      <item value="Whether the requested redirect URI &quot;matches&quot; the specified redirect URI. For a URL, this implementation tests if the user requested redirect starts with the registered redirect, so it would have the same host and root path if it is an HTTP URL. The port, userinfo, query params also matched. Request redirect uri path can include additional parameters which are ignored for the match &lt;p&gt; For other (non-URL) cases, such as for some implicit clients, the redirect_uri must be an exact match. @param requestedRedirect The requested redirect URI. @param redirectUri The registered redirect URI. @return Whether the requested redirect URI &quot;matches&quot; the specified redirect URI." />
      <item value="Attempt to match one of the registered URIs to the that of the requested one. @param redirectUris the set of the registered URIs to try and find a match. This cannot be null or empty. @param requestedRedirect the URI used as part of the request @return redirect uri @throws RedirectMismatchException if no match was found" />
      <item value="The resolved redirect URI is either the redirect_uri from the parameters or the one from clientDetails. Either way we need to store it on the AuthorizationRequest." />
      <item value="The resolved redirect URI of this request. A URI may be present in the original request, in the authorizationParameters, or it may not be provided, in which case it will be defaulted (by processing classes) to the Client's default registered value." />
      <item value="Temporal Field" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="183" />
        <entry key="CHINESE_TRADITIONAL" value="2" />
        <entry key="ENGLISH" value="184" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
</application>