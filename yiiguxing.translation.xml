<application>
  <component name="AppStorage">
    <histories>
      <item value="check Is Under Approval" />
      <item value="校验是否在审批中" />
      <item value="check Is Aprronvaling" />
      <item value="矩阵经理工号字符串" />
      <item value="总裁审核工号字符串" />
      <item value="总裁决策工号字符串" />
      <item value="开阀批准报告" />
      <item value="获取组织n级部门负责人信息" />
      <item value="select Org Manager Info" />
      <item value="中心部门code" />
      <item value="负责人" />
      <item value="中心负责人" />
      <item value="级别" />
      <item value="等级" />
      <item value="获取中心负责人" />
      <item value="重新签批" />
      <item value="责任人用户名列表" />
      <item value="current user has no permission to this project" />
      <item value="approval User Names" />
      <item value="APPLY" />
      <item value="不适用申请" />
      <item value="签批人" />
      <item value="责任人" />
      <item value="阀门交付物签批" />
      <item value="G 10固定成员" />
      <item value="valve" />
      <item value="Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is {@link java.util.stream.BaseStreamclose() closed} after its contents have been placed into this stream. (If a mapped stream is {@code null} an empty stream is used, instead.) &lt;p&gt;This is an &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;intermediate operation&lt;a&gt;. @apiNote The {@code flatMap()} operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream. &lt;p&gt;&lt;b&gt;Examples.&lt;b&gt; &lt;p&gt;If {@code orders} is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders: &lt;pre&gt;{@code orders.flatMap(order -&gt; order.getLineItems().stream())... }&lt;pre&gt; &lt;p&gt;If {@code path} is the path to a file, then the following produces a stream of the {@code words} contained in that file: &lt;pre&gt;{@code Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8); Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(&quot; +&quot;))); }&lt;pre&gt; The {@code mapper} function passed to {@code flatMap} splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array. @param &lt;R&gt; The element type of the new stream @param mapper a &lt;a href=&quot;package-summary.htmlNonInterference&quot;&gt;non-interfering&lt;a&gt;, &lt;a href=&quot;package-summary.htmlStatelessness&quot;&gt;stateless&lt;a&gt; function to apply to each element which produces a stream of new values @return the new stream" />
      <item value="Returns a {@code Stream} consisting of the elements of this stream, each boxed to an {@code Integer}. &lt;p&gt;This is an &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;intermediate operation&lt;a&gt;. @return a {@code Stream} consistent of the elements of this stream, each boxed to an {@code Integer}" />
      <item value="步骤整合" />
      <item value="不合法" />
      <item value="Approval" />
      <item value="出现业务异常" />
      <item value="Eligible to terminate" />
      <item value="Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination" />
      <item value="Causes this thread to begin execution; the Java Virtual Machine calls the &lt;code&gt;run&lt;code&gt; method of this thread. &lt;p&gt; The result is that two threads are running concurrently: the current thread (which returns from the call to the &lt;code&gt;start&lt;code&gt; method) and the other thread (which executes its &lt;code&gt;run&lt;code&gt; method). &lt;p&gt; It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution. @exception IllegalThreadStateException if the thread was already started. @see run() @see stop()" />
      <item value="校验是否可禁用" />
      <item value="拼接" />
      <item value="get If Present" />
      <item value="biz Unique Key" />
      <item value="length" />
      <item value="Deprecated" />
      <item value="Column" />
      <item value="组件" />
      <item value="Compent Export Config" />
      <item value="导出明细表" />
      <item value="表单明细" />
      <item value="send" />
      <item value="Sent" />
      <item value="荷兰" />
      <item value="biz" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1688459304722" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1701675293687" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="-1109" />
    <option name="newTranslationDialogY" value="445" />
    <histories>
      <item value="Whether the requested redirect URI &quot;matches&quot; the specified redirect URI. For a URL, this implementation tests if the user requested redirect starts with the registered redirect, so it would have the same host and root path if it is an HTTP URL. The port, userinfo, query params also matched. Request redirect uri path can include additional parameters which are ignored for the match &lt;p&gt; For other (non-URL) cases, such as for some implicit clients, the redirect_uri must be an exact match. @param requestedRedirect The requested redirect URI. @param redirectUri The registered redirect URI. @return Whether the requested redirect URI &quot;matches&quot; the specified redirect URI." />
      <item value="Attempt to match one of the registered URIs to the that of the requested one. @param redirectUris the set of the registered URIs to try and find a match. This cannot be null or empty. @param requestedRedirect the URI used as part of the request @return redirect uri @throws RedirectMismatchException if no match was found" />
      <item value="get Authorization Code Response" />
      <item value="get Implicit Grant Response" />
      <item value="Used to indicate to {@code AbstractSecurityInterceptor} whether it should present the authentication token to the &lt;code&gt;AuthenticationManager&lt;code&gt;. Typically an &lt;code&gt;AuthenticationManager&lt;code&gt; (or, more often, one of its &lt;code&gt;AuthenticationProvider&lt;code&gt;s) will return an immutable authentication token after successful authentication, in which case that token can safely return &lt;code&gt;true&lt;code&gt; to this method. Returning &lt;code&gt;true&lt;code&gt; will improve performance, as calling the &lt;code&gt;AuthenticationManager&lt;code&gt; for every request will no longer be necessary. &lt;p&gt; For security reasons, implementations of this interface should be very careful about returning &lt;code&gt;true&lt;code&gt; from this method unless they are either immutable, or have some way of ensuring the properties have not been changed since original creation. @return true if the token has been authenticated and the &lt;code&gt;AbstractSecurityInterceptor&lt;code&gt; does not need to present the token to the &lt;code&gt;AuthenticationManager&lt;code&gt; again for re-authentication." />
      <item value="Authentication" />
      <item value="Authorization Request" />
      <item value="Some systems may allow for approval decisions to be remembered or approved by default. Check for such logic here, and set the approved flag on the authorization request accordingly." />
      <item value="authorization Request" />
      <item value="Convenient strategy for configuring an OAUth2 Authorization Server. Beans of this type are applied to the Spring context automatically if you {@link EnableAuthorizationServer @EnableAuthorizationServer}. @author Dave Syer" />
      <item value="O Auth 2 Authentication" />
      <item value="get O Auth 2 Authentication" />
      <item value="Facade" />
      <item value="Attachment Permisson Facade" />
      <item value="&lt;p&gt; Implementation of the Authorization Endpoint from the OAuth2 specification. Accepts authorization requests, and handles user approval if the grant type is authorization code. The tokens themselves are obtained from the {@link TokenEndpoint Token Endpoint}, except in the implicit grant type (where they come from the Authorization Endpoint via &lt;code&gt;response_type=token&lt;code&gt;. &lt;p&gt; &lt;p&gt; This endpoint should be secured so that it is only accessible to fully authenticated users (as a minimum requirement) since it represents a request from a valid user to act on his or her behalf. &lt;p&gt; @author Dave Syer @author Vladimir Kryachko" />
      <item value="Performs Http session-related functionality when a new authentication occurs. @throws SessionAuthenticationException if it is decided that the authentication is not allowed for the session. This will typically be because the user has too many sessions open at once." />
      <item value="attempt Authentication" />
      <item value="An {@link org.springframework.security.core.Authentication} implementation that is designed for simple presentation of a username and password. &lt;p&gt; The &lt;code&gt;principal&lt;code&gt; and &lt;code&gt;credentials&lt;code&gt; should be set with an &lt;code&gt;Object&lt;code&gt; that provides the respective property via its &lt;code&gt;Object.toString()&lt;code&gt; method. The simplest such &lt;code&gt;Object&lt;code&gt; to use is &lt;code&gt;String&lt;code&gt;. @author Ben Alex" />
      <item value="The credentials that prove the principal is correct. This is usually a password, but could be anything relevant to the &lt;code&gt;AuthenticationManager&lt;code&gt;. Callers are expected to populate the credentials. @return the credentials that prove the identity of the &lt;code&gt;Principal&lt;code&gt;" />
      <item value="get Credentials" />
      <item value="Set by an &lt;code&gt;AuthenticationManager&lt;code&gt; to indicate the authorities that the principal has been granted. Note that classes should not rely on this value as being valid unless it has been set by a trusted &lt;code&gt;AuthenticationManager&lt;code&gt;. &lt;p&gt; Implementations should ensure that modifications to the returned collection array do not affect the state of the Authentication object, or use an unmodifiable instance. &lt;p&gt; @return the authorities granted to the principal, or an empty collection if the token has not been authenticated. Never null." />
      <item value="Represents the token for an authentication request or for an authenticated principal once the request has been processed by the {@link AuthenticationManagerauthenticate(Authentication)} method. &lt;p&gt; Once the request has been authenticated, the &lt;tt&gt;Authentication&lt;tt&gt; will usually be stored in a thread-local &lt;tt&gt;SecurityContext&lt;tt&gt; managed by the {@link SecurityContextHolder} by the authentication mechanism which is being used. An explicit authentication can be achieved, without using one of Spring Security's authentication mechanisms, by creating an &lt;tt&gt;Authentication&lt;tt&gt; instance and using the code: &lt;pre&gt; SecurityContextHolder.getContext().setAuthentication(anAuthentication); &lt;pre&gt; Note that unless the &lt;tt&gt;Authentication&lt;tt&gt; has the &lt;tt&gt;authenticated&lt;tt&gt; property set to &lt;tt&gt;true&lt;tt&gt;, it will still be authenticated by any security interceptor (for method or web invocations) which encounters it. &lt;p&gt; In most cases, the framework transparently takes care of managing the security context and authentication objects for you. @author Ben Alex" />
      <item value="retrieve User" />
      <item value="Allows subclasses to actually retrieve the &lt;code&gt;UserDetails&lt;code&gt; from an implementation-specific location, with the option of throwing an &lt;code&gt;AuthenticationException&lt;code&gt; immediately if the presented credentials are incorrect (this is especially useful if it is necessary to bind to a resource as the user in order to obtain or generate a &lt;code&gt;UserDetails&lt;code&gt;). &lt;p&gt; Subclasses are not required to perform any caching, as the &lt;code&gt;AbstractUserDetailsAuthenticationProvider&lt;code&gt; will by default cache the &lt;code&gt;UserDetails&lt;code&gt;. The caching of &lt;code&gt;UserDetails&lt;code&gt; does present additional complexity as this means subsequent requests that rely on the cache will need to still have their credentials validated, even if the correctness of credentials was assured by subclasses adopting a binding-based strategy in this method. Accordingly it is important that subclasses either disable caching (if they want to ensure that this method is the only method that is capable of authenticating a request, as no &lt;code&gt;UserDetails&lt;code&gt; will ever be cached) or ensure subclasses implement {@link additionalAuthenticationChecks(UserDetails, UsernamePasswordAuthenticationToken)} to compare the credentials of a cached &lt;code&gt;UserDetails&lt;code&gt; with subsequent authentication requests. &lt;p&gt; &lt;p&gt; Most of the time subclasses will not perform credentials inspection in this method, instead performing it in {@link additionalAuthenticationChecks(UserDetails, UsernamePasswordAuthenticationToken)} so that code related to credentials validation need not be duplicated across two methods. &lt;p&gt; @param username The username to retrieve @param authentication The authentication request, which subclasses &lt;em&gt;may&lt;em&gt; need to perform a binding-based retrieval of the &lt;code&gt;UserDetails&lt;code&gt; @return the user information (never &lt;code&gt;null&lt;code&gt; - instead an exception should the thrown) @throws AuthenticationException if the credentials could not be validated (generally a &lt;code&gt;BadCredentialsException&lt;code&gt;, an &lt;code&gt;AuthenticationServiceException&lt;code&gt; or &lt;code&gt;UsernameNotFoundException&lt;code&gt;)" />
      <item value="authenticate" />
      <item value="Attempts to authenticate the passed {@link Authentication} object, returning a fully populated &lt;code&gt;Authentication&lt;code&gt; object (including granted authorities) if successful. &lt;p&gt; An &lt;code&gt;AuthenticationManager&lt;code&gt; must honour the following contract concerning exceptions: &lt;ul&gt; &lt;li&gt;A {@link DisabledException} must be thrown if an account is disabled and the &lt;code&gt;AuthenticationManager&lt;code&gt; can test for this state.&lt;li&gt; &lt;li&gt;A {@link LockedException} must be thrown if an account is locked and the &lt;code&gt;AuthenticationManager&lt;code&gt; can test for account locking.&lt;li&gt; &lt;li&gt;A {@link BadCredentialsException} must be thrown if incorrect credentials are presented. Whilst the above exceptions are optional, an &lt;code&gt;AuthenticationManager&lt;code&gt; must &lt;B&gt;always&lt;B&gt; test credentials.&lt;li&gt; &lt;ul&gt; Exceptions should be tested for and if applicable thrown in the order expressed above (i.e. if an account is disabled or locked, the authentication request is immediately rejected and the credentials testing process is not performed). This prevents credentials being tested against disabled or locked accounts. @param authentication the authentication request object @return a fully authenticated object including credentials @throws AuthenticationException if authentication fails" />
      <item value="Processes an {@link Authentication} request. @author Ben Alex" />
      <item value="Interface for granters of access tokens. Various grant types are defined in the specification, and each of those has an implementation, leaving room for extensions to the specification as needed. @author Dave Syer" />
      <item value="The scope was requested or determined during the authorization step" />
      <item value="Implicit" />
      <item value="authenticated Client" />
      <item value="This interface represents the abstract notion of a principal, which can be used to represent any entity, such as an individual, a corporation, and a login id. @see java.security.cert.X509Certificate @author Li Gong" />
      <item value="Principal" />
      <item value="Represents an authority granted to an {@link Authentication} object. &lt;p&gt; A &lt;code&gt;GrantedAuthority&lt;code&gt; must either represent itself as a &lt;code&gt;String&lt;code&gt; or be specifically supported by an {@link AccessDecisionManager}. @author Ben Alex" />
      <item value="This constructor can be safely used by any code that wishes to create a &lt;code&gt;UsernamePasswordAuthenticationToken&lt;code&gt;, as the {@link isAuthenticated()} will return &lt;code&gt;false&lt;code&gt;." />
      <item value="public UsernamePasswordAuthenticationToken(Object principal, Object credentials) { super(null); this.principal = principal; this.credentials = credentials; setAuthenticated(false); }" />
      <item value="Indicates that the implementing object contains sensitive data, which can be erased using the {@code eraseCredentials} method. Implementations are expected to invoke the method on any internal objects which may also implement this interface. &lt;p&gt; For internal framework use only. Users who are writing their own {@code AuthenticationProvider} implementations should create and return an appropriate {@code Authentication} object there, minus any sensitive data, rather than using this interface. @author Luke Taylor @since 3.0.3" />
      <item value="Indicates whether to write the headers at the beginning of the request." />
      <item value="Filter implementation to add headers to the current response. Can be useful to add certain headers which enable browser protection. Like X-Frame-Options, X-XSS-Protection and X-Content-Type-Options. @author Marten Deinum @author Josh Cummings @author Ankur Pathak @since 3.2" />
      <item value="tuned" />
      <item value="proof" />
      <item value="合格率" />
      <item value="recruiting" />
      <item value="print Even" />
      <item value="幂等" />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method. As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="complement" />
      <item value="business Dir" />
      <item value="pivot" />
      <item value="option" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="121" />
        <entry key="ENGLISH" value="122" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
      </map>
    </option>
  </component>
</application>