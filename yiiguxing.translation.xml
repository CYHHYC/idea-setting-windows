<application>
  <component name="AppStorage">
    <histories>
      <item value="check Is Under Approval" />
      <item value="校验是否在审批中" />
      <item value="check Is Aprronvaling" />
      <item value="矩阵经理工号字符串" />
      <item value="总裁审核工号字符串" />
      <item value="总裁决策工号字符串" />
      <item value="开阀批准报告" />
      <item value="获取组织n级部门负责人信息" />
      <item value="select Org Manager Info" />
      <item value="中心部门code" />
      <item value="负责人" />
      <item value="中心负责人" />
      <item value="级别" />
      <item value="等级" />
      <item value="获取中心负责人" />
      <item value="重新签批" />
      <item value="责任人用户名列表" />
      <item value="current user has no permission to this project" />
      <item value="approval User Names" />
      <item value="APPLY" />
      <item value="不适用申请" />
      <item value="签批人" />
      <item value="责任人" />
      <item value="阀门交付物签批" />
      <item value="G 10固定成员" />
      <item value="valve" />
      <item value="Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is {@link java.util.stream.BaseStreamclose() closed} after its contents have been placed into this stream. (If a mapped stream is {@code null} an empty stream is used, instead.) &lt;p&gt;This is an &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;intermediate operation&lt;a&gt;. @apiNote The {@code flatMap()} operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream. &lt;p&gt;&lt;b&gt;Examples.&lt;b&gt; &lt;p&gt;If {@code orders} is a stream of purchase orders, and each purchase order contains a collection of line items, then the following produces a stream containing all the line items in all the orders: &lt;pre&gt;{@code orders.flatMap(order -&gt; order.getLineItems().stream())... }&lt;pre&gt; &lt;p&gt;If {@code path} is the path to a file, then the following produces a stream of the {@code words} contained in that file: &lt;pre&gt;{@code Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8); Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(&quot; +&quot;))); }&lt;pre&gt; The {@code mapper} function passed to {@code flatMap} splits a line, using a simple regular expression, into an array of words, and then creates a stream of words from that array. @param &lt;R&gt; The element type of the new stream @param mapper a &lt;a href=&quot;package-summary.htmlNonInterference&quot;&gt;non-interfering&lt;a&gt;, &lt;a href=&quot;package-summary.htmlStatelessness&quot;&gt;stateless&lt;a&gt; function to apply to each element which produces a stream of new values @return the new stream" />
      <item value="Returns a {@code Stream} consisting of the elements of this stream, each boxed to an {@code Integer}. &lt;p&gt;This is an &lt;a href=&quot;package-summary.htmlStreamOps&quot;&gt;intermediate operation&lt;a&gt;. @return a {@code Stream} consistent of the elements of this stream, each boxed to an {@code Integer}" />
      <item value="步骤整合" />
      <item value="不合法" />
      <item value="Approval" />
      <item value="出现业务异常" />
      <item value="Eligible to terminate" />
      <item value="Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination" />
      <item value="Causes this thread to begin execution; the Java Virtual Machine calls the &lt;code&gt;run&lt;code&gt; method of this thread. &lt;p&gt; The result is that two threads are running concurrently: the current thread (which returns from the call to the &lt;code&gt;start&lt;code&gt; method) and the other thread (which executes its &lt;code&gt;run&lt;code&gt; method). &lt;p&gt; It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution. @exception IllegalThreadStateException if the thread was already started. @see run() @see stop()" />
      <item value="校验是否可禁用" />
      <item value="拼接" />
      <item value="get If Present" />
      <item value="biz Unique Key" />
      <item value="length" />
      <item value="Deprecated" />
      <item value="Column" />
      <item value="组件" />
      <item value="Compent Export Config" />
      <item value="导出明细表" />
      <item value="表单明细" />
      <item value="send" />
      <item value="Sent" />
      <item value="荷兰" />
      <item value="biz" />
    </histories>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1688459304722" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1705549031639" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="-1109" />
    <option name="newTranslationDialogY" value="445" />
    <histories>
      <item value="Returns a {@code Collector} implementing a cascaded &quot;group by&quot; operation on input elements of type {@code T}, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream {@code Collector}. &lt;p&gt;The classification function maps elements to some key type {@code K}. The downstream collector operates on elements of type {@code T} and produces a result of type {@code D}. The resulting collector produces a {@code Map&lt;K, D&gt;}. &lt;p&gt;There are no guarantees on the type, mutability, serializability, or thread-safety of the {@code Map} returned. &lt;p&gt;For example, to compute the set of last names of people in each city: &lt;pre&gt;{@code Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); }&lt;pre&gt; @implNote The returned {@code Collector} is not concurrent. For parallel stream pipelines, the {@code combiner} function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using {@link groupingByConcurrent(Function, Collector)} may offer better parallel performance. @param &lt;T&gt; the type of the input elements @param &lt;K&gt; the type of the keys @param &lt;A&gt; the intermediate accumulation type of the downstream collector @param &lt;D&gt; the result type of the downstream reduction @param classifier a classifier function mapping input elements to keys @param downstream a {@code Collector} implementing the downstream reduction @return a {@code Collector} implementing the cascaded group-by operation @see groupingBy(Function) @see groupingBy(Function, Supplier, Collector) @see groupingByConcurrent(Function, Collector)" />
      <item value="Flips this buffer. The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded. &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;i&gt; operations, invoke this method to prepare for a sequence of channel-write or relative &lt;i&gt;get&lt;i&gt; operations. For example: &lt;blockquote&gt;&lt;pre&gt; buf.put(magic); Prepend header in.read(buf); Read data into rest of buffer buf.flip(); Flip buffer out.write(buf); Write header + data to channel&lt;pre&gt;&lt;blockquote&gt; &lt;p&gt; This method is often used in conjunction with the {@link java.nio.ByteBuffercompact compact} method when transferring data from one place to another. &lt;p&gt; @return This buffer" />
      <item value="key Allowed" />
      <item value="A {@code Closeable} is a source or destination of data that can be closed. The close method is invoked to release resources that the object is holding (such as open files). @since" />
      <item value="Custom Config" />
      <item value="Costom Config" />
      <item value="自定义" />
      <item value="REVISE" />
      <item value="Publish Application Sor Service" />
      <item value="Permission Application Service" />
      <item value="Company Standard Abolish Service" />
      <item value="通知" />
      <item value="Approver" />
      <item value="analysis Point" />
      <item value="create Model Point" />
      <item value="递归" />
      <item value="算法" />
      <item value="Collapse Builder" />
      <item value="探索者" />
      <item value="explorer" />
      <item value="agenda" />
      <item value="密级" />
      <item value="运维需求" />
      <item value="expect" />
      <item value="except" />
      <item value="标准3 d" />
      <item value="stand 3 d Type" />
      <item value="actual Editable" />
      <item value="Copy the property values of the given source bean into the given target bean. &lt;p&gt;Note: The source and target classes do not have to match or even be derived from each other, as long as the properties match. Any bean properties that the source bean exposes but the target bean does not will silently be ignored. &lt;p&gt;As of Spring Framework 5.3, this method honors generic type information when matching properties in the source and target objects. See the documentation for {@link copyProperties(Object, Object)} for details. @param source the source bean @param target the target bean @param editable the class (or interface) to restrict property setting to @param ignoreProperties array of property names to ignore @throws BeansException if the copying failed @see BeanWrapper" />
      <item value="commit" />
      <item value="distinguish commercial commit" />
      <item value="恶魔" />
      <item value="乏味" />
      <item value="枯燥的" />
      <item value="Check if host matches the registered value. @param registered the registered host. Can be null. @param requested the requested host. Can be null. @return true if they match" />
      <item value="get Scheme" />
      <item value="Whether the requested redirect URI &quot;matches&quot; the specified redirect URI. For a URL, this implementation tests if the user requested redirect starts with the registered redirect, so it would have the same host and root path if it is an HTTP URL. The port, userinfo, query params also matched. Request redirect uri path can include additional parameters which are ignored for the match &lt;p&gt; For other (non-URL) cases, such as for some implicit clients, the redirect_uri must be an exact match. @param requestedRedirect The requested redirect URI. @param redirectUri The registered redirect URI. @return Whether the requested redirect URI &quot;matches&quot; the specified redirect URI." />
      <item value="Attempt to match one of the registered URIs to the that of the requested one. @param redirectUris the set of the registered URIs to try and find a match. This cannot be null or empty. @param requestedRedirect the URI used as part of the request @return redirect uri @throws RedirectMismatchException if no match was found" />
      <item value="The resolved redirect URI is either the redirect_uri from the parameters or the one from clientDetails. Either way we need to store it on the AuthorizationRequest." />
      <item value="The resolved redirect URI of this request. A URI may be present in the original request, in the authorizationParameters, or it may not be provided, in which case it will be defaulted (by processing classes) to the Client's default registered value." />
      <item value="Temporal Field" />
      <item value="Chrono Field" />
      <item value="A standard set of fields. &lt;p&gt; This set of fields provide field-based access to manipulate a date, time or date-time. The standard set of fields can be extended by implementing {@link TemporalField}. &lt;p&gt; These fields are intended to be applicable in multiple calendar systems. For example, most non-ISO calendar systems define dates as a year, month and day, just with slightly different rules. The documentation of each field explains how it operates. @implSpec This is a final, immutable and thread-safe enum. @since 1.8" />
      <item value="Gets the value of the specified field from this date as an {@code int}. &lt;p&gt; This queries this date for the value of the specified field. The returned value will always be within the valid range of values for the field. If it is not possible to return the value, because the field is not supported or for some other reason, an exception is thrown. &lt;p&gt; If the field is a {@link ChronoField} then the query is implemented here. The {@link isSupported(TemporalField) supported fields} will return valid values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in an {@code int} and throw a {@code DateTimeException}. All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}. &lt;p&gt; If the field is not a {@code ChronoField}, then the result of this method is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)} passing {@code this} as the argument. Whether the value can be obtained, and what the value represents, is determined by the field. @param field the field to get, not null @return the value for the field @throws DateTimeException if a value for the field cannot be obtained or the value is outside the range of valid values for the field @throws UnsupportedTemporalTypeException if the field is not supported or the range of values exceeds an {@code int} @throws ArithmeticException if numeric overflow occurs" />
      <item value="Gets the current value of the default locale for this instance of the Java Virtual Machine. &lt;p&gt; The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the {@link setDefault(java.util.Locale) setDefault} method. @return the default locale for this instance of the Java Virtual Machine" />
      <item value="Gets the {@code LocalTime} part of this date-time. &lt;p&gt; This returns a {@code LocalTime} with the same hour, minute, second and nanosecond as this date-time. @return the time part of this date-time, not null" />
      <item value="A date without a time-zone in the ISO-8601 calendar system, such as {@code 2007-12-03}. &lt;p&gt; {@code LocalDate} is an immutable date-time object that represents a date, often viewed as year-month-day. Other date fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. For example, the value &quot;2nd October 2007&quot; can be stored in a {@code LocalDate}. &lt;p&gt; This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone. &lt;p&gt; The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable. &lt;p&gt; This is a &lt;a href=&quot;{@docRoot}javalangdoc-filesValueBased.html&quot;&gt;value-based&lt;a&gt; class; use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on instances of {@code LocalDate} may have unpredictable results and should be avoided. The {@code equals} method should be used for comparisons. @implSpec This class is immutable and thread-safe. @since 1.8" />
      <item value="Gets the day-of-week field, which is an enum {@code DayOfWeek}. &lt;p&gt; This method returns the enum {@link DayOfWeek} for the day-of-week. This avoids confusion as to what {@code int} values mean. If you need access to the primitive {@code int} value then the enum provides the {@link DayOfWeekgetValue() int value}. &lt;p&gt; Additional information can be obtained from the {@code DayOfWeek}. This includes textual names of the values. @return the day-of-week, not null" />
      <item value="Traversal" />
      <item value="This class hides and serves as a substitute for the underlying logging system's MDC implementation. &lt;p&gt; If the underlying logging system offers MDC functionality, then SLF4J's MDC, i.e. this class, will delegate to the underlying system's MDC. Note that at this time, only two logging systems, namely log4j and logback, offer MDC functionality. For java.util.logging which does not support MDC, {@link BasicMDCAdapter} will be used. For other systems, i.e. slf4j-simple and slf4j-nop, {@link NOPMDCAdapter} will be used. &lt;p&gt; Thus, as a SLF4J user, you can take advantage of MDC in the presence of log4j, logback, or java.util.logging, but without forcing these systems as dependencies upon your users. &lt;p&gt; For more information on MDC please see the &lt;a href=&quot;http:logback.qos.chmanualmdc.html&quot;&gt;chapter on MDC&lt;a&gt; in the logback manual. &lt;p&gt; Please note that all methods in this class are static. @author Ceki G&amp;uuml;lc&amp;uuml; @since 1.4.1" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="174" />
        <entry key="CHINESE_TRADITIONAL" value="2" />
        <entry key="ENGLISH" value="175" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
</application>